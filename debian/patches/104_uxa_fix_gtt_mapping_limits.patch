This is a backport of 3 patches from Chris Wilson
<chris@chris-wilson.co.uk> that fixes issues with loading or rotating
large images.

commit 85d3dc5910a2eea3a10b822e01443e11eaae9291
Date:   Fri Dec 2 10:22:51 2011 +0000
    uxa: Reset size limits based on AGP size

commit f6c82c73b673ec3c9cce432fe38d5e0076234efd
Date:   Fri Dec 2 10:34:10 2011 +0000
    uxa: Fix runtime linking of previous commit

commit 735219cd59e6184a6622d3d429a704ca3f58b9cd
Date:   Fri Dec 2 10:42:00 2011 +0000
    uxa: Ensure that we can fallback with all of (src, mask, dst) as GTT mappings


diff -Nurp patched/src/intel_display.c build/src/intel_display.c
--- patched/src/intel_display.c	2012-02-15 17:31:03.643780719 -0800
+++ build/src/intel_display.c	2012-02-15 17:28:32.779466879 -0800
@@ -411,8 +411,6 @@ intel_crtc_apply(xf86CrtcPtr crtc)
 		}
 	}
 
-	intel_set_gem_max_sizes(scrn);
-
 	if (scrn->pScreen)
 		xf86_reload_cursors(scrn->pScreen);
 
diff -Nurp patched/src/intel_driver.c build/src/intel_driver.c
--- patched/src/intel_driver.c	2012-02-15 17:31:03.643780719 -0800
+++ build/src/intel_driver.c	2012-02-15 17:28:59.439522179 -0800
@@ -1164,8 +1164,6 @@ static Bool I830EnterVT(int scrnIndex, i
 			   strerror(errno));
 	}
 
-	intel_set_gem_max_sizes(scrn);
-
 	intel_copy_fb(scrn);
 
 	if (!xf86SetDesiredModes(scrn))
diff -Nurp patched/src/intel.h build/src/intel.h
--- patched/src/intel.h	2012-02-15 17:31:03.643780719 -0800
+++ build/src/intel.h	2012-02-15 17:26:25.543203927 -0800
@@ -543,7 +543,6 @@ int intel_crtc_to_pipe(xf86CrtcPtr crtc)
 unsigned long intel_get_fence_size(intel_screen_private *intel, unsigned long size);
 unsigned long intel_get_fence_pitch(intel_screen_private *intel, unsigned long pitch,
 				   uint32_t tiling_mode);
-void intel_set_gem_max_sizes(ScrnInfoPtr scrn);
 
 drm_intel_bo *intel_allocate_framebuffer(ScrnInfoPtr scrn,
 					int w, int h, int cpp,
diff -Nurp patched/src/intel_memory.c build/src/intel_memory.c
--- patched/src/intel_memory.c	2012-02-15 17:30:43.823739363 -0800
+++ build/src/intel_memory.c	2012-02-15 17:30:25.571701312 -0800
@@ -169,6 +169,39 @@ static inline int intel_pad_drawable_wid
 	return ALIGN(width, 64);
 }
 
+
+static size_t
+agp_aperture_size(struct pci_device *dev, int gen)
+{
+	return dev->regions[gen < 30 ? 0 : 2].size;
+}
+
+static void intel_set_gem_max_sizes(ScrnInfoPtr scrn)
+{
+	intel_screen_private *intel = intel_get_screen_private(scrn);
+	size_t agp_size = agp_aperture_size(intel->PciInfo,
+					    INTEL_INFO(intel)->gen);
+
+	/* The chances of being able to mmap an object larger than
+	 * agp_size/2 are slim. Moreover, we may be forced to fallback
+	 * using a gtt mapping as both the source and a mask, as well
+	 * as a destination and all need to fit into the aperture.
+	 */
+	intel->max_gtt_map_size = agp_size / 4;
+
+	/* Let objects be tiled up to the size where only 4 would fit in
+	 * the aperture, presuming best case alignment. Also if we
+	 * cannot mmap it using the GTT we will be stuck. */
+	intel->max_tiling_size = intel->max_gtt_map_size;
+
+	/* Large BOs will tend to hit SW fallbacks frequently, and also will
+	 * tend to fail to successfully map when doing SW fallbacks because we
+	 * overcommit address space for BO access, or worse cause aperture
+	 * thrashing.
+	 */
+	intel->max_bo_size = intel->max_gtt_map_size;
+}
+
 /**
  * Allocates a framebuffer for a screen.
  *
@@ -249,56 +282,3 @@ retry:
 
 	return front_buffer;
 }
-
-static void intel_set_max_bo_size(intel_screen_private *intel,
-				 const struct drm_i915_gem_get_aperture *aperture)
-{
-	if (aperture->aper_available_size)
-		/* Large BOs will tend to hit SW fallbacks frequently, and also will
-		 * tend to fail to successfully map when doing SW fallbacks because we
-		 * overcommit address space for BO access, or worse cause aperture
-		 * thrashing.
-		 */
-		intel->max_bo_size = aperture->aper_available_size / 2;
-	else
-		intel->max_bo_size = 64 * 1024 * 1024;
-}
-
-static void intel_set_max_gtt_map_size(intel_screen_private *intel,
-				      const struct drm_i915_gem_get_aperture *aperture)
-{
-	if (aperture->aper_available_size)
-		/* Let objects up get bound up to the size where only 2 would fit in
-		 * the aperture, but then leave slop to account for alignment like
-		 * libdrm does.
-		 */
-		intel->max_gtt_map_size =
-			aperture->aper_available_size * 3 / 4 / 2;
-	else
-		intel->max_gtt_map_size = 16 * 1024 * 1024;
-}
-
-static void intel_set_max_tiling_size(intel_screen_private *intel,
-				     const struct drm_i915_gem_get_aperture *aperture)
-{
-	if (aperture->aper_available_size)
-		/* Let objects be tiled up to the size where only 4 would fit in
-		 * the aperture, presuming worst case alignment.
-		 */
-		intel->max_tiling_size = aperture->aper_available_size / 4;
-	else
-		intel->max_tiling_size = 4 * 1024 * 1024;
-}
-
-void intel_set_gem_max_sizes(ScrnInfoPtr scrn)
-{
-	intel_screen_private *intel = intel_get_screen_private(scrn);
-	struct drm_i915_gem_get_aperture aperture;
-
-	aperture.aper_available_size = 0;
-	drmIoctl(intel->drmSubFD, DRM_IOCTL_I915_GEM_GET_APERTURE, &aperture);
-
-	intel_set_max_bo_size(intel, &aperture);
-	intel_set_max_gtt_map_size(intel, &aperture);
-	intel_set_max_tiling_size(intel, &aperture);
-}
