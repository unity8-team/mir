commit 6211d0914e2ed1cdd4cc2e170ee16129fc9f0d73
Author: Chris Wilson <chris@chris-wilson.co.uk>
Date:   Wed Sep 5 12:33:08 2012 +0100

    uxa: Flush batch immediately after queuing a WAIT_FOR_EVENT
    
    We still encounter hangs with kernel-3.5 with the culprit being a wait
    on a disabled pipe. As we thoroughly check before that the pipe is still
    disabled and flush before a modeset, the only possibility that remains
    is that DPMS is disabling the pipe before we submit. Close that race by
    always submitting the batch immediately after a WAIT_FOR_EVENT.
    
    Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>

diff --git a/src/intel_dri.c b/src/intel_dri.c
index fa1660c..a1bac9a 100644
--- a/src/intel_dri.c
+++ b/src/intel_dri.c
@@ -540,6 +540,11 @@ I830DRI2CopyRegion(DrawablePtr drawable, RegionPtr pRegion,
 			  0, 0);
 
 	FreeScratchGC(gc);
+
+	/* And make sure the WAIT_FOR_EVENT is queued before any
+	 * modesetting/dpms operations on the pipe.
+	 */
+	intel_batch_submit(scrn);
 }
 
 #if DRI2INFOREC_VERSION >= 4
diff --git a/src/intel_video.c b/src/intel_video.c
index 0be72e2..09782aa 100644
--- a/src/intel_video.c
+++ b/src/intel_video.c
@@ -1585,6 +1585,11 @@ I830PutImageTextured(ScrnInfoPtr scrn,
 	intel_get_screen_private(scrn)->needs_flush = TRUE;
 	DamageDamageRegion(drawable, clipBoxes);
 
+	/* And make sure the WAIT_FOR_EVENT is queued before any
+	 * modesetting/dpms operations on the pipe.
+	 */
+	intel_batch_submit(scrn);
+
 	return Success;
 }
 
