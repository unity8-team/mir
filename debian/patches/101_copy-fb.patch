Index: xserver-xorg-video-intel/src/intel.h
===================================================================
--- xserver-xorg-video-intel.orig/src/intel.h	2011-06-02 17:16:53.871343985 +1000
+++ xserver-xorg-video-intel/src/intel.h	2011-06-02 17:16:59.491377184 +1000
@@ -433,6 +433,7 @@
 	OptionInfoPtr Options;
 
 	/* Driver phase/state information */
+	Bool starting;
 	Bool suspended;
 
 	enum last_3d last_3d;
@@ -462,6 +463,7 @@
 extern int intel_get_pipe_from_crtc_id(drm_intel_bufmgr *bufmgr, xf86CrtcPtr crtc);
 extern int intel_crtc_id(xf86CrtcPtr crtc);
 extern int intel_output_dpms_status(xf86OutputPtr output);
+extern void intel_copy_fb(ScrnInfoPtr scrn);
 
 enum DRI2FrameEventType {
 	DRI2_SWAP,
Index: xserver-xorg-video-intel/src/intel_display.c
===================================================================
--- xserver-xorg-video-intel.orig/src/intel_display.c	2011-06-02 17:16:53.841343805 +1000
+++ xserver-xorg-video-intel/src/intel_display.c	2011-06-02 17:16:59.491377184 +1000
@@ -36,6 +36,8 @@
 #include <errno.h>
 #include <poll.h>
 
+#include <sys/ioctl.h>
+
 #include "xorgVersion.h"
 
 #include "intel.h"
@@ -932,6 +934,13 @@
 	drmModeConnectorPtr koutput = intel_output->mode_output;
 	struct intel_mode *mode = intel_output->mode;
 	int i;
+	intel_screen_private *intel = intel_get_screen_private(output->scrn);
+
+	/* xf86Crtc.c calls dpms off in set desired modes, so ignore
+	 * the request if we're starting up. */
+
+	if (intel->starting)
+		return;
 
 	for (i = 0; i < koutput->count_props; i++) {
 		drmModePropertyPtr props;
@@ -1618,6 +1627,11 @@
 	}
 
 	intel->modes = mode;
+
+#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) < 9
+	scrn->canDoBGNoneRoot = TRUE;
+#endif
+
 	return TRUE;
 }
 
@@ -1687,3 +1701,100 @@
 	struct intel_crtc *intel_crtc = crtc->driver_private;
 	return intel_crtc->pipe;
 }
+
+static PixmapPtr
+intel_create_pixmap_for_fbcon(ScrnInfoPtr scrn)
+{
+	xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(scrn);
+	struct intel_crtc *intel_crtc = xf86_config->crtc[0]->driver_private;
+	ScreenPtr pScreen = screenInfo.screens[scrn->scrnIndex];
+	struct intel_mode *mode = intel_crtc->mode;
+	intel_screen_private *intel = intel_get_screen_private(scrn);
+	drmModeFBPtr fbcon = NULL;
+	struct drm_gem_flink flink;
+	drm_intel_bo *bo;
+	PixmapPtr pixmap = NULL;
+	int i;
+
+	for (i = 0; i < mode->mode_res->count_crtcs; i++) {
+		intel_crtc = xf86_config->crtc[i]->driver_private;
+		if (intel_crtc->mode_crtc->buffer_id == 0)
+			continue;
+		fbcon = drmModeGetFB(mode->fd,
+				     intel_crtc->mode_crtc->buffer_id);
+		if (fbcon != NULL)
+			break;
+	}
+	if (i == mode->mode_res->count_crtcs)
+		return NULL;
+
+	flink.handle = fbcon->handle;
+	if (ioctl(mode->fd, DRM_IOCTL_GEM_FLINK, &flink) < 0) {
+		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
+			   "Couldn't flink fbcon handle\n");
+		return NULL;
+	}
+
+	bo = drm_intel_bo_gem_create_from_name(intel->bufmgr,
+					       "fbcon", flink.name);
+	if (bo == NULL) {
+		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
+			   "Couldn't allocate bo for fbcon handle\n");
+		return NULL;
+	}
+	if (!CreateScratchPixmapsForScreen(pScreen->myNum))
+		return NULL;
+
+	pixmap = GetScratchPixmapHeader(pScreen,
+					fbcon->width, fbcon->height,
+					fbcon->depth, fbcon->bpp,
+					fbcon->pitch, NULL);
+	if (pixmap == NULL) {
+		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
+			   "Couldn't allocate pixmap fbcon contents\n");
+		return NULL;
+	}
+
+	intel_set_pixmap_bo(pixmap, bo);
+	drm_intel_bo_unreference(bo);
+	drmModeFreeFB(fbcon);
+
+	return pixmap;
+}
+
+void intel_copy_fb(ScrnInfoPtr scrn)
+{
+	ScreenPtr pScreen = screenInfo.screens[scrn->scrnIndex];
+	intel_screen_private *intel = intel_get_screen_private(scrn);
+	PixmapPtr src, dst;
+	unsigned int pitch = scrn->displayWidth * intel->cpp;
+
+	src = intel_create_pixmap_for_fbcon(scrn);
+	if (src == NULL) {
+		xf86DrvMsg(scrn->scrnIndex, X_ERROR,
+			   "Couldn't create pixmap for fbcon\n");
+		return;
+	}
+
+	/* We dont have a screen Pixmap yet */
+	dst = GetScratchPixmapHeader(pScreen,
+				     scrn->virtualX, scrn->virtualY,
+				     scrn->depth, scrn->bitsPerPixel,
+				     pitch,
+				     NULL);
+	intel_set_pixmap_bo(dst, intel->front_buffer);
+
+	intel->uxa_driver->prepare_copy(src, dst, -1, -1, GXcopy, FB_ALLONES);
+
+	intel->uxa_driver->copy(dst, 0, 0, 0, 0,
+				scrn->virtualX, scrn->virtualY);
+
+	intel->uxa_driver->done_copy(dst);
+
+	intel_batch_submit_internal(scrn, TRUE);
+
+	(*pScreen->DestroyPixmap)(src);
+	(*pScreen->DestroyPixmap)(dst);
+	FreeScratchPixmapsForScreen(pScreen->myNum);
+}
+
Index: xserver-xorg-video-intel/src/intel_driver.c
===================================================================
--- xserver-xorg-video-intel.orig/src/intel_driver.c	2011-06-02 17:16:53.891344097 +1000
+++ xserver-xorg-video-intel/src/intel_driver.c	2011-06-02 17:16:59.491377184 +1000
@@ -935,6 +935,10 @@
 		intel->directRenderingType = DRI_DRI2;
 #endif
 
+#if GET_ABI_MAJOR(ABI_VIDEODRV_VERSION) >= 9
+	screen->canDoBGNoneRoot = TRUE;
+#endif
+
 	if (!intel_init_initial_framebuffer(scrn))
 		return FALSE;
 
@@ -943,6 +947,8 @@
 	if (INTEL_INFO(intel)->gen >= 40)
 		gen4_render_state_init(scrn);
 
+	intel->starting = FALSE;
+
 	miClearVisualTypes();
 	if (!miSetVisualTypes(scrn->depth,
 			      miGetDefaultVisualMask(scrn->depth),
@@ -1078,6 +1084,7 @@
 
 	intel_mode_init(intel);
 
+	intel->starting = FALSE;
 	intel->suspended = FALSE;
 
 #if HAVE_UDEV
@@ -1147,6 +1154,8 @@
 
 	intel_set_gem_max_sizes(scrn);
 
+	intel_copy_fb(scrn);
+
 	if (!xf86SetDesiredModes(scrn))
 		return FALSE;
 
Index: xserver-xorg-video-intel/src/intel_batchbuffer.c
===================================================================
--- xserver-xorg-video-intel.orig/src/intel_batchbuffer.c	2011-06-02 17:16:53.861343922 +1000
+++ xserver-xorg-video-intel/src/intel_batchbuffer.c	2011-06-02 17:30:50.535856598 +1000
@@ -182,7 +182,7 @@
 	return intel_get_pixmap_private(pixmap)->batch_write;
 }
 
-void intel_batch_submit(ScrnInfoPtr scrn)
+void intel_batch_submit_internal(ScrnInfoPtr scrn, Bool force_flush)
 {
 	intel_screen_private *intel = intel_get_screen_private(scrn);
 	int ret;
@@ -241,7 +241,7 @@
 		}
 	}
 
-	intel->needs_flush |= intel_batch_needs_flush(intel);
+	intel->needs_flush |= force_flush ? TRUE : intel_batch_needs_flush(intel);
 
 	while (!list_is_empty(&intel->batch_pixmaps)) {
 		struct intel_pixmap *entry;
@@ -282,6 +282,11 @@
 	intel->current_batch = 0;
 }
 
+void intel_batch_submit(ScrnInfoPtr scrn)
+{
+    intel_batch_submit_internal(scrn, FALSE);
+}
+
 void intel_debug_flush(ScrnInfoPtr scrn)
 {
 	intel_screen_private *intel = intel_get_screen_private(scrn);
Index: xserver-xorg-video-intel/src/intel_batchbuffer.h
===================================================================
--- xserver-xorg-video-intel.orig/src/intel_batchbuffer.h	2011-06-02 17:16:53.821343687 +1000
+++ xserver-xorg-video-intel/src/intel_batchbuffer.h	2011-06-02 17:16:59.491377184 +1000
@@ -38,6 +38,7 @@
 void intel_batch_emit_flush(ScrnInfoPtr scrn);
 void intel_batch_do_flush(ScrnInfoPtr scrn);
 void intel_batch_submit(ScrnInfoPtr scrn);
+void intel_batch_submit_internal(ScrnInfoPtr scrn, Bool force_flush);
 
 static inline int intel_batch_space(intel_screen_private *intel)
 {
