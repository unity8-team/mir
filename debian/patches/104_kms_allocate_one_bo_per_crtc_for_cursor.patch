From 2786a66719a6dbb735eb7c551c412475c30ffa51 Mon Sep 17 00:00:00 2001
From: Keith Packard <keithp@keithp.com>
Date: Tue, 25 Aug 2009 18:35:54 -0700
Subject: [PATCH 2506/2543] KMS: allocate one bo per crtc for cursor

The KMS API doesn't provide for sharing a single bo for multiple
cursor images, so allocate one bo for each crtc to hold the cursor
image. KMS also only supports ARGB cursors, so don't bother to
allocate buffers for two color cursors.

Signed-off-by: Keith Packard <keithp@keithp.com>
---
 src/drmmode_display.c |   16 +++++++++-----
 src/i830.h            |    2 +
 src/i830_memory.c     |   51 ++++++++++++++++++++++++++++--------------------
 3 files changed, 42 insertions(+), 27 deletions(-)

diff --git a/src/drmmode_display.c b/src/drmmode_display.c
index 404f8b9..24c7659 100644
--- a/src/drmmode_display.c
+++ b/src/drmmode_display.c
@@ -421,12 +421,11 @@ drmmode_set_cursor_position (xf86CrtcPtr crtc, int x, int y)
 static void
 drmmode_load_cursor_argb (xf86CrtcPtr crtc, CARD32 *image)
 {
-	ScrnInfoPtr pScrn = crtc->scrn;
-	I830Ptr pI830 = I830PTR(pScrn);
+	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
 	int ret;
 
 	/* cursor should be mapped already */
-	ret = dri_bo_subdata(pI830->cursor_mem->bo, 0, 64*64*4, image);
+	ret = dri_bo_subdata(drmmode_crtc->cursor, 0, 64*64*4, image);
 	if (ret)
 		xf86DrvMsg(crtc->scrn->scrnIndex, X_ERROR,
 			   "failed to set cursor: %s", strerror(-ret));
@@ -450,11 +449,9 @@ drmmode_show_cursor (xf86CrtcPtr crtc)
 {
 	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
 	drmmode_ptr drmmode = drmmode_crtc->drmmode;
-	ScrnInfoPtr pScrn = crtc->scrn;
-	I830Ptr pI830 = I830PTR(pScrn);
 
 	drmModeSetCursor(drmmode->fd, drmmode_crtc->mode_crtc->crtc_id,
-			 pI830->cursor_mem->bo->handle, 64, 64);
+			 drmmode_crtc->cursor->handle, 64, 64);
 }
 
 static void *
@@ -600,6 +597,13 @@ drmmode_crtc_init(ScrnInfoPtr pScrn, drmmode_ptr drmmode, int num)
 	return;
 }
 
+void
+drmmode_crtc_set_cursor_bo(xf86CrtcPtr crtc, dri_bo *cursor)
+{
+	drmmode_crtc_private_ptr drmmode_crtc = crtc->driver_private;
+	drmmode_crtc->cursor = cursor;
+}
+
 static xf86OutputStatus
 drmmode_output_detect(xf86OutputPtr output)
 {
diff --git a/src/i830.h b/src/i830.h
index b46eff1..3b2d166 100644
--- a/src/i830.h
+++ b/src/i830.h
@@ -693,6 +693,8 @@ void I830DRI2CloseScreen(ScreenPtr pScreen);
 extern Bool drmmode_pre_init(ScrnInfoPtr pScrn, int fd, int cpp);
 extern int drmmode_get_pipe_from_crtc_id(drm_intel_bufmgr *bufmgr, xf86CrtcPtr crtc);
 extern int drmmode_output_dpms_status(xf86OutputPtr output);
+void
+drmmode_crtc_set_cursor_bo(xf86CrtcPtr crtc, dri_bo *cursor);
 
 extern Bool i830_crtc_on(xf86CrtcPtr crtc);
 extern int i830_crtc_to_pipe(xf86CrtcPtr crtc);
diff --git a/src/i830_memory.c b/src/i830_memory.c
index 434510a..26e4cfd 100644
--- a/src/i830_memory.c
+++ b/src/i830_memory.c
@@ -1134,18 +1134,20 @@ i830_allocate_cursor_buffers(ScrnInfoPtr pScrn)
 
     flags |= DISABLE_REUSE;
 
-    /* Try to allocate one big blob for our cursor memory.  This works
-     * around a limitation in the FreeBSD AGP driver that allows only one
-     * physical allocation larger than a page, and could allow us
-     * to pack the cursors smaller.
-     */
-    size = xf86_config->num_crtc * (HWCURSOR_SIZE + HWCURSOR_SIZE_ARGB);
+    if (!pI830->use_drm_mode) {
+	/* Try to allocate one big blob for our cursor memory.  This works
+	 * around a limitation in the FreeBSD AGP driver that allows only one
+	 * physical allocation larger than a page, and could allow us
+	 * to pack the cursors smaller.
+	 */
+	size = xf86_config->num_crtc * (HWCURSOR_SIZE + HWCURSOR_SIZE_ARGB);
 
-    pI830->cursor_mem = i830_allocate_memory(pScrn, "HW cursors",
-					     size, PITCH_NONE, GTT_PAGE_SIZE,
-					     flags, TILE_NONE);
-    if (pI830->cursor_mem != NULL)
-	return TRUE;
+	pI830->cursor_mem = i830_allocate_memory(pScrn, "HW cursors",
+						 size, PITCH_NONE, GTT_PAGE_SIZE,
+						 flags, TILE_NONE);
+	if (pI830->cursor_mem != NULL)
+	    return TRUE;
+    }
 
     /*
      * Allocate four separate buffers when the kernel doesn't support
@@ -1154,15 +1156,17 @@ i830_allocate_cursor_buffers(ScrnInfoPtr pScrn)
      */
     for (i = 0; i < xf86_config->num_crtc; i++)
     {
-	pI830->cursor_mem_classic[i] = i830_allocate_memory (pScrn, 
-							     "Core cursor",
-							     HWCURSOR_SIZE,
-							     PITCH_NONE,
-							     GTT_PAGE_SIZE,
-							     flags,
-							     TILE_NONE);
-	if (!pI830->cursor_mem_classic[i])
-	    return FALSE;
+	if (!pI830->use_drm_mode) {
+	    pI830->cursor_mem_classic[i] = i830_allocate_memory (pScrn,
+								 "Core cursor",
+								 HWCURSOR_SIZE,
+								 PITCH_NONE,
+								 GTT_PAGE_SIZE,
+								 flags,
+								 TILE_NONE);
+	    if (!pI830->cursor_mem_classic[i])
+		return FALSE;
+	}
 	pI830->cursor_mem_argb[i] = i830_allocate_memory (pScrn, "ARGB cursor",
 							  HWCURSOR_SIZE_ARGB,
 							  PITCH_NONE,
@@ -1575,7 +1579,12 @@ i830_bind_all_memory(ScrnInfoPtr pScrn)
 		FatalError("Couldn't bind memory for BO %s\n", mem->name);
 	}
     }
-    if (!pI830->use_drm_mode)
+    if (pI830->use_drm_mode) {
+	int	i;
+	xf86CrtcConfigPtr xf86_config = XF86_CRTC_CONFIG_PTR(pScrn);
+	for (i = 0; i < xf86_config->num_crtc; i++)
+	    drmmode_crtc_set_cursor_bo(xf86_config->crtc[i], pI830->cursor_mem_argb[i]->bo);
+    } else
 	i830_update_cursor_offsets(pScrn);
     i830_set_max_gtt_map_size(pScrn);
 
-- 
1.6.3.3

